
DROP TABLE IF EXISTS Etudiant;
CREATE TABLE Etudiant ( 
Etudiant_id serial  primary key, 
Nom varchar(20), 
Prenom varchar(20),
nom_grp varchar(30)
); 

INSERT INTO Etudiant(etudiant_id, nom, prenom, nom_grp) VALUES ('1','Antoine','Dupont',’Pegasus’);
INSERT INTO Etudiant(etudiant_id, nom, prenom, nom_grp) VALUES ('2','Yerock',’Yann',’Draco’);
INSERT INTO Etudiant(etudiant_id, nom, prenom, nom_grp) VALUES ('3','Dupont',’Silvain',’Cygnus’);

DROP TABLE IF EXISTS Professeur;
CREATE TABLE Professeur ( 
Prof_id serial primary key,
Nom_prof varchar(20), 
Prenom_prof varchar(20)
Matiere_id varchar(20) references Matiere(Matiere_id),  ); 

INSERT INTO Professeur(prof_id, nom_prof, prenom_prof) VALUES ('1','bereau','chris');
INSERT INTO Professeur(prof_id, nom_prof, prenom_prof) VALUES ('2',maignan','luck');
INSERT INTO Professeur(prof_id, nom_prof, prenom_prof) VALUES ('3','varane','hugo');

DROP TABLE IF EXISTS Matiere;
CREATE TABLE Matiere (  
Matiere_id varchar(20) primary key, 
Matiere varchar );

INSERT INTO Matiere(Matiere_id, matiere) VALUES ('Java','Developpement Java');
INSERT INTO Matiere(Matiere_id, matiere) VALUES ('BDD','Dev Java');
INSERT INTO Matiere(Matiere_id, matiere) VALUES ('Com','Communication');

DROP TABLE IF EXISTS Notes;
CREATE TABLE Notes ( 
Etudiant_id int references Etudiant( Etudiant_id ), 
Controle_id int references Controle(Controle_id),	
Note decimal(4,2),
Coef float,
primary key(Controle_id,Etudiant_id) );

INSERT INTO Notes(Etudiant_id, Controle_id, Note, Coef) VALUES ('1','2','14','2');
INSERT INTO Notes(Etudiant_id, Controle_id, Note, Coef) VALUES ('2','2','14','2');
INSERT INTO Notes(Etudiant_id, Controle_id, Note, Coef) VALUES ('3','1','14','2');


DROP TABLE IF EXISTS UE;
CREATE TABLE UE (
Ue_id int primary key,
Matiere_id varchar(20) references Matiere( Matiere_id ),
Etudiant_id int references Etudiant(Etudiant_id ),
Nom_ue varchar (60),
Note_ue float,num_sae int references SAE(num_sae),
prof_id int references Professeur(prof_id) );


DROP TABLE IF EXISTS Controle;
CREATE TABLE Controle ( 
Controle_id serial primary key, 
Matiere_id varchar(20) references Matiere( Matiere_id ), 
Controle varchar ); 

INSERT INTO Controle( controle_id, matiere_id, controle) VALUES ('1','Java','Controle Court');
INSERT INTO Controle( controle_id, matiere_id, controle) VALUES ('2','BDD','Controle long');
INSERT INTO Controle( controle_id, matiere_id, controle) VALUES ('3','Com','Oral n1');


DROP TABLE IF EXISTS SAE;
CREATE TABLE SAE (
num_sae int primary key,
etudiant_id int references Etudiant( etudiant_id ),
ue_id int references Ue (ue_id ),
matiere_id varchar(20) references Matiere(matiere_id),
prof_id int references Professeur( prof_id ),
nom_sae varchar (20),
note_sae float,
coef_sae float
);

DROP TABLE IF EXISTS Responsable_matiere;
CREATE TABLE Responsable_matiere ( 
resp_id int primary key, 
Nom_resp varchar(20), 
Prenom_rep varchar(20),
Matiere_id varchar(20) references Matiere( Matiere_id )
); 

INSERT INTO Responsable_matiere(resp_id, Nom_resp, Prenom_rep, Matiere_id) VALUES ('1','bereau','chris', 'BDD');
INSERT INTO Responsable_matiere(resp_id, Nom_resp, Prenom_rep, Matiere_id) VALUES ('2','maignan','luck', 'IHM');
INSERT INTO Responsable_matiere(resp_id, Nom_resp, Prenom_rep, Matiere_id) VALUES ('3','Varane','hugo', 'Java');


DROP TABLE IF EXISTS Semestre,
CREATE TABLE Semestre ( 
Semestre_id int  primary key,
Semestre varchar(20),
Note_semestre float,
Com_Semestre varchar(100),
matiere_id varchar references Matiere (Matiere_id),
ue_id int references Ue (Ue_id),
etudiant_id int references Etudiant (Etudiant_id),
prof_id int references Professeur (Prof_id) );


-- III.Visualisation de Données

-- 1. Définir un ensemble de données dérivées à visualiser


-- La note max d'un élève
-- La note min d'un élève
-- Les notes d'un élève
-- La moyenne d'un élève



-- 1. VUES ;

-- Vue qui affiche les notes de l'étudiant ;

DROP VIEW IF EXISTS Etu_note;
CREATE VIEW Etu_note AS 
SELECT n.etudiant_id, Nom, Prenom, c.Controle_id, n.note, m.Matiere_id
FROM Matiere m, Controle c, Notes n, Etudiant e
WHERE m.Matiere_id=c.Matiere_id
AND c.controle_id = n.controle_id
AND n.etudiant_id = e.etudiant_id
GROUP BY n.etudiant_id, Nom, Prenom, c.Controle_id, m.Matiere_id,n.note;

Select * from Etu_note order by etudiant_id;

-- Vue qui affiche la moyenne par matièresl de l'étudiant ;


DROP view IF EXISTS Moyennes_matiere; 
CREATE VIEW Moyennes_matiere
AS
SELECT e.etudiant_id, Nom, Prenom, m.Matiere_id, Matiere,
avg(note) as moyenne
FROM Etudiant e, Matiere m, Controle c, Notes n
WHERE m.Matiere_id=c.Matiere_id
AND c. Controle_id =n. Controle_id
AND n. Etudiant_id =e. Etudiant_id
GROUP BY e.etudiant_id, Nom, Prenom, m.Matiere_id, Matiere;

Select * from moyennes_matiere order by etudiant_id;

-- Vue qui affiche la note max de l'étudiant ;

DROP VIEW IF EXISTS Note_Max;
CREATE VIEW Note_Max
AS
SELECT e.etudiant_id, Nom, Prenom, m.Matiere_id, Matiere,
MAX(note) as NOTE_MAX
FROM Etudiant e, Matiere m, Controle c, Notes n
WHERE m.Matiere_id=c.Matiere_id
AND c. Controle_id =n. Controle_id
AND n. Etudiant_id =e. Etudiant_id
GROUP BY e.etudiant_id, Nom, Prenom, m.Matiere_id, Matiere;

SELECT * from Note_max order by etudiant_id;

 


-- Vue qui affiche la note minimal de l'étudiant ;

CREATE VIEW Note_Min
AS
SELECT e.etudiant_id, Nom, Prenom, m.Matiere_id, Matiere,
MIN(note) as NOTE_MIN
FROM Etudiant e, Matiere m, Controle c, Notes n
WHERE m.Matiere_id=c.Matiere_id
AND c. Controle_id =n. Controle_id
AND n. Etudiant_id =e. Etudiant_id
GROUP BY e.etudiant_id, Nom, Prenom, m.Matiere_id, Matiere;

SELECT * from Note_Min order by etudiant_id;



-- 2. Procédures :

-- Une fonction qui calcule le nombre d'étudiants dans la promotion.
-- Une fonction qui calcule le nombre de profs dans la promotion.
-- Une fonction qui calcule le nombre d’étudiants par groupe
-- Une fonction qui calcule le nombre de responsables matières dans la promotion.
-- Fonction qui vérifie le bon nombre d’SAE et de compétences.











-- Fonction qui compte le nombres d’étudiant dans la promo ;


CREATE OR REPLACE FUNCTION Nb_etudiant (out nb int) AS 
$$
DECLARE

nbetu_curs REFCURSOR;
i int;
BEGIN
		nb=0;
		OPEN nbetu_curs FOR 
SELECT DISTINCT etudiant_id FROM Etudiant;

LOOP

FETCH nbetu_curs into i;
EXIT WHEN NOT FOUND;
nb=nb+1;

	END LOOP;
CLOSE nbetu_curs;
END;
$$ language plpgsql;

-- Fonction qui compte le nombres de professeurs dans la promo ;


CREATE OR REPLACE FUNCTION Nombre_prof (out nbp int) AS
$$
DECLARE

 prof_curs  REFCURSOR;
i int;


BEGIN
	nbp=0;
	OPEN prof_curs FOR 
	SELECT prof_id FROM Professeur;
LOOP
FETCH prof_curs into i;
EXIT WHEN NOT FOUND;
nbp=nbp+1;
	END LOOP;
CLOSE prof_curs;
END;

$$ language plpgsql;





-- Fonction qui compte le nombres d’étudiants par groupe ;

CREATE OR REPLACE FUNCTION Groupe_total (out grp varchar, out nbt int) RETURNS 
    SETOF RECORD AS
    
        $$

DECLARE
    
    etuid_curs CURSOR (grpe varchar) FOR
        SELECT Etudiant_id
        FROM Etudiant
        WHERE nom_grp = grpe;
    
    nomgrp_curs CURSOR FOR 
    SELECT distinct nom_grp from Etudiant;
    i int;
BEGIN
    OPEN nomgrp_curs;
    LOOP

        FETCH nomgrp_curs into grp;
        EXIT WHEN NOT FOUND;
         nbt = 0;
        OPEN etuid_curs(grp);

    LOOP
FETCH etuid_curs into i;
        EXIT WHEN NOT FOUND;
        nbt = nbt+1;
        
    END LOOP;
    
     close etuid_curs;
     
     RETURN NEXT;
    END LOOP;
    close nomgrp_curs;
    RETURN;
END;

$$ language plpgsql;

-- Fonction qui compte le nombres de responsables matières dans la promo ;


CREATE OR REPLACE FUNCTION Nombre_resp_mat (out nb int) AS
$$
DECLARE

 resp_mat_curs CURSOR  FOR
	SELECT resp_id FROM Responsable_matiere;
i int;


BEGIN
		nb=0;
OPEN resp_mat_curs;
	LOOP
FETCH resp_mat_curs into i;
EXIT WHEN NOT FOUND;
nb=nb+1;

	END LOOP;
	CLOSE resp_mat_curs;
END;
$$ language plpgsql;




-- Fonction qui vérifie qu’il y’a bien 6 SAE;


CREATE OR REPLACE FUNCTION Nombre_sae (out nb int)
AS
$$
DECLARE
nbsae_curs CURSOR FOR
SELECT num_sae FROM SAE;
i int;
BEGIN
nb=0;
OPEN nbsae_curs;
LOOP
FETCH nbsae_curs into i;
EXIT WHEN NOT FOUND;
nb=nb+1;
END LOOP;
CLOSE nbsae_curs;

IF nb < 6 THEN
    RAISE EXCEPTION 'Il n’y a pas 6 SAE';

END IF;
END;
$$ language plpgsql;



-- Fonction qui vérifie qu’il y’a bien 6 compétences;


CREATE OR REPLACE FUNCTION Nombre_ue (out nb int)
AS
$$
DECLARE
nbue_curs CURSOR FOR
SELECT ue_id FROM SAE;
i int;
BEGIN
nb=0;
OPEN nbue_curs;
LOOP
FETCH nbue_curs into i;
EXIT WHEN NOT FOUND;
nb=nb+1;
END LOOP;
CLOSE nbue_curs;
		IF nb < 6 THEN
    		RAISE EXCEPTION 'Il n y a pas 6 compétences';
END IF;
END;
$$ language plpgsql;















-- IV. Restrictions d’accès aux données ;

-- 1. Les règles d'accès aux données ;


-- Fonction + Trigger qui enregistre toutes modifications sur la table Notes.
-- Fonction + Trigger qui empêche d’entrer une note inférieure à 0.
-- Un étudiant ne peut visualiser que ces propres notes (VUE+FONCTION)
-- Un enseignant doit pouvoir saisir les notes de ses contrôles. 
-- Les étudiant ont un rôle étudiant
-- Les prof et responsable matière on a role avec des droits.



-- 2. Procédures :


-- ENREGISTREMENTS DE TOUS CHANGEMENTS SUR LA TABLE NOTES.

DROP table IF EXISTS controle_note_audit;
DROP table IF EXISTS Note_controle;

CREATE TABLE controle_note_audit (
    action text, -- INSERT/UPDATE/DELETE
    action_timestamp timestamp -- estampille
    default current_timestamp,
    old_note Notes , -- tuple supprime ou avant maj
    new_note Notes -- tuple insere ou apres maj
 );





CREATE OR REPLACE function Note_audit_trig() 
    returns TRIGGER as
$$
    BEGIN
        IF TG_OP = 'INSERT' THEN
            INSERT INTO controle_note_audit
            (action, new_note) 
            values('INSERT', NEW);
        END IF;

        IF TG_OP = 'UPDATE' THEN
            INSERT INTO controle_note_audit
            (action, old_note, new_note) 
            values('UPDATE', OLD, NEW);
        END IF;

        IF TG_OP = 'DELETE' THEN
            INSERT INTO controle_note_audit
            (action, old_note) 
            values('DELETE', OLD);
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER Note_trig
AFTER 
    INSERT or UPDATE or DELETE ON Notes
    FOR EACH ROW
    EXECUTE PROCEDURE Note_audit_trig();



	





-- CONTRÔLE TOUS CHANGEMENTS SUR LA TABLE NOTE,
-- SI LA NOTE EST INFÉRIEUR À 0 ALORS RIEN EST FAIT + UN MESSAGE D’ERREUR EST RETOURNER. 

DROP TRIGGER IF EXISTS Note_trig on Notes;

Create or replace function verificationNotes() 
    returns TRIGGER as
$$
    BEGIN

        IF TG_OP = 'INSERT' THEN
            IF NEW.Note < 0 THEN
		RAISE EXCEPTION 'Note inférieur à 0';
        
RETURN NULL;
        END IF;
END IF;

    IF TG_OP = 'UPDATE' THEN
            IF NEW.Note < 0 THEN 
		RAISE EXCEPTION 'Note inférieur à 0'; 
RETURN NULL;
            END IF;
END IF;

   RETURN NULL;
    END;
$$ LANGUAGE plpgsql;


CREATE Trigger verif_note_trig 
    BEFORE
    UPDATE or INSERT on Notes
        FOR EACH ROW
        EXECUTE PROCEDURE verificationNotes();


-- Un élève peut voir ces propres résultats sous forme de fonction


CREATE FUNCTION MesResultats( out Matiere_id varchar(10), out Controle varchar,
 out Note decimal(4,2))
 RETURNS setof RECORD
AS
 $$
 SELECT m.Matiere_id , c.Controle , n.Note
 FROM Etudiant e, Matiere m, Controle c, Notes n
 WHERE m.Matiere_id=c.Matiere_id
 AND c. Controle_id =n. Controle_id
 AND n. Etudiant_id =e. Etudiant_id
 AND e.Nom= session_user;
 $$ language SQL
 SECURITY DEFINER;

-- Un élève peut voir ces propres notes sous forme de fonction


CREATE OR REPLACE FUNCTION MesNotes( out Matiere_id varchar(20), out Controle_id varchar,
out Note decimal(4,2), out Nom varchar)
returns setof record
as
$$
SELECT m.Matiere_id , c.Controle_id , n.Note, e.Nom
FROM Etudiant e natural join Controle c natural join Notes n natural join Matiere m
WHERE e.Nom = session_user
AND m.Matiere_id=c.Matiere_id
AND c.Controle_id=n.Controle_id;
$$ language SQL
SECURITY DEFINER;




-- Un élève peut voir ces propres SAE sous forme de fonction


CREATE OR REPLACE FUNCTION MesSAE(out nom_sae varchar (20), out note_sae float, out coef_sae float, out Nom varchar)
 returns setof record
 as
 $$
 SELECT nom_sae , note_sae , coef_sae, Nom
 FROM SAE natural join Etudiant e
 WHERE e.Nom = session_user;
 $$ language SQL
 SECURITY DEFINER;



-- Un élève peut voir ces propres compétences sous forme de fonction

CREATE FUNCTION MesUE(out Nom_ue varchar (20),out Note_ue float, out Nom varchar)
 returns setof record
 as
 $$
 SELECT Nom_ue , Note_ue, Nom
 FROM Etudiant e natural join UE
 WHERE e.Nom = session_user;
 $$ language SQL
 SECURITY DEFINER;










Un élève peut voir ces propres notes sous forme de VUE.

DROP VIEW IF EXISTS Mes_notes;
CREATE VIEW Mes_notes AS
SELECT n.etudiant_id, Nom, Prenom, c.Controle_id, n.note,
m.Matiere_id
FROM Matiere m, Controle c, Notes n, Etudiant e
WHERE Nom = current_user;
AND c.controle_id = n.controle_id
AND n.etudiant_id = e.etudiant_id
AND m.Matiere_id=c.Matiere_id
GROUP BY n.etudiant_id, Nom, Prenom, c.Controle_id,
m.Matiere_id,n.note;
$$ language SQL
SECURITY DEFINER;




Restrictions d'accès aux Données


Création d’utilisateurs

Création des rôles

Affectation des rôles aux utilisateurs concernés 

Définition des droits d’accès sur les VUES avec seulement le droit de SELECT au rôle Etudiant.

Définition des droits d’accès sur les Tables Notes, Controle et Matiere  avec les droits de SELECT, UPDATE, INSERT et DELETE au rôle Professeur.

Définition des droits d’accès sur toutes les tables de la base de données au rôle Admin de la base de données qui pourra en cas de soucis régler les problèmes de celle-ci.




CREATE USER varane WITH PASSWORD 'hugo';
CREATE USER maignan WITH PASSWORD 'luck';

CREATE USER alloune WITH PASSWORD 'aymane';
CREATE USER john WITH PASSWORD ‘jelain’;


CREATE ROLE Professeur WITH LOGIN PASSWORD 'prof';
CREATE ROLE Etudiant WITH LOGIN PASSWORD 'eleve';
CREATE ROLE Responsable_mat WITH LOGIN PASSWORD 'resp';
CREATE ROLE Admin_bdd WITH LOGIN PASSWORD 'admin';


GRANT Professeur TO maignan;
GRANT Professeur TO varane;

GRANT Etudiant TO dupont;
GRANT Etudiant TO yerock;

GRANT SELECT ON etu_note TO Etudiant;
GRANT SELECT ON Moyennes_matiere TO Etudiant;
GRANT SELECT ON Note_Max TO Etudiant;
GRANT SELECT ON Note_Min TO Etudiant;
GRANT SELECT ON Mes_notes TO Etudiant;


GRANT SELECT, UPDATE, INSERT, DELETE ON Notes TO Professeur;
GRANT SELECT, UPDATE, INSERT, DELETE ON Controle TO Professeur;
GRANT SELECT, UPDATE, INSERT, DELETE ON Matiere TO Professeur;


GRANT ALL PRIVILEGES ON Matiere TO Admin_bdd;
GRANT ALL PRIVILEGES ON Etudiant TO Admin_bdd;
GRANT ALL PRIVILEGES ON Professeur TO Admin_bdd;

